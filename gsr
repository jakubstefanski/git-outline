#!/bin/bash

if ((${BASH_VERSION%%.*} < 4)); then
	echo "${0} requires Bash version 4 or later" >&2
	exit 1
fi

set -eu

readonly SIGN_NONE=' '
readonly SIGN_LOOSE='L'
readonly SIGN_DIRTY='D'
readonly SIGN_REMOTE_UNAVAILABLE='R'
readonly SIGN_BEHIND='B'
readonly SIGN_AHEAD='A'
readonly PORCELAIN_STATUS_LENGTH=6

function check_status() {
	local repo="${1}"
	local status=()
	local local_branch=''
	local remote_branch=''

	# Loose repositories
	if [[ ! $(git remote 2>/dev/null) ]]; then
		status+=("${SIGN_LOOSE}")
	fi

	# Dirty repositories
	if [[ $(git status --porcelain) ]]; then
		status+=("${SIGN_DIRTY}")
	fi

	# Remote unavailable
	if ! git fetch --quiet &>/dev/null; then
		status+=("${SIGN_REMOTE_UNAVAILABLE}")
	fi

	local_branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)
	remote_branch=$(git rev-parse --abbrev-ref --symbolic-full-name @\{u\} 2>/dev/null)
	if [[ "${remote_branch}" ]]; then
		if [ "$(git rev-list "${remote_branch}..${local_branch}" --count)" -gt '0' ]; then
			status+=("${SIGN_AHEAD}")
		fi
		if [ "$(git rev-list "${local_branch}..${remote_branch}" --count)" -gt '0' ]; then
			status+=("${SIGN_BEHIND}")
		fi
	fi

	# Padding and space for future extensions without breaking porcelain
	while [ "${#status[@]}" -lt "${PORCELAIN_STATUS_LENGTH}" ]; do
		status+=("${SIGN_NONE}")
	done

	printf '%s' "${status[@]}"
}

function should_use_colors() {
	if [[ ! -t 1 ]]; then
		return 1 # not a terminal, for example pager
	fi

	case "${TERM}" in
	xterm-color | *-256color) return 0 ;;
	esac

	if [ -x /usr/bin/tput ] && tput setaf 1 >&/dev/null; then
		return 0
	fi

	return 1
}

function main() {
	# Map (repo => porcelain status)
	declare -A statuses
	while IFS= read -rd '' gitconfig; do
		repo=$(dirname "$(dirname "${gitconfig}")")
		statuses["${repo}"]="$(cd "${repo}" && check_status "${repo}")"
	done < <(find . -type f -path '*/.git/config' -print0)

	# Sorted repos for pretty and consistent output
	declare -a repos
	if [ ${#statuses[@]} -gt 0 ]; then
		while IFS= read -rd '' repo; do
			repos+=("${repo}")
		done < <(printf '%s\0' "${!statuses[@]}" | sort -z)
	fi

	# Print summary
	local red=''
	local reset=''

	if should_use_colors; then
		red='\e[0;31m'
		reset='\e[0m'
	fi

	for repo in "${repos[@]}"; do
		local porcelain="${statuses[${repo}]}"
		if [[ ! -z "${porcelain// /}" ]]; then
			echo -e "${red}${porcelain}${reset} ${repo}"
		fi
	done
}

main
