#!/bin/bash

if ((${BASH_VERSION%%.*} < 4)); then
	echo "${0} requires Bash version 4 or later" >&2
	exit 1
fi

set -eu

readonly SIGN_NONE=' '
readonly SIGN_LOOSE='L'
readonly SIGN_DIRTY='D'
readonly SIGN_REMOTE_UNAVAILABLE='R'
readonly SIGN_BEHIND='B'
readonly SIGN_AHEAD='A'
readonly PORCELAIN_STATUS_LENGTH=6

function check_status() {
	local repo="${1}"
	local status=()
	local local_branch=''
	local remote_branch=''

	# Loose repositories
	if [[ ! $(git remote 2>/dev/null) ]]; then
		status+=("${SIGN_LOOSE}")
	fi

	# Dirty repositories
	if [[ $(git status --porcelain) ]]; then
		status+=("${SIGN_DIRTY}")
	fi

	# Remote unavailable
	if ! git fetch --quiet &>/dev/null; then
		status+=("${SIGN_REMOTE_UNAVAILABLE}")
	fi

	local_branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)
	remote_branch=$(git rev-parse --abbrev-ref --symbolic-full-name @\{u\} 2>/dev/null)
	if [[ "${remote_branch}" ]]; then
		if [ "$(git rev-list "${remote_branch}..${local_branch}" --count)" -gt '0' ]; then
			status+=("${SIGN_AHEAD}")
		fi
		if [ "$(git rev-list "${local_branch}..${remote_branch}" --count)" -gt '0' ]; then
			status+=("${SIGN_BEHIND}")
		fi
	fi

	# Padding and space for future extensions without breaking porcelain
	while [ "${#status[@]}" -lt "${PORCELAIN_STATUS_LENGTH}" ]; do
		status+=("${SIGN_NONE}")
	done

	printf '%s' "${status[@]}"
}

# Map (name => porcelain status)
declare -A repos_map
while IFS= read -rd '' gitconfig; do
	repo=$(dirname "$(dirname "${gitconfig}")")
	repos_map["${repo}"]="$(cd "${repo}" && check_status "${repo}")"
done < <(find . -type f -path '*/.git/config' -print0)

# Sorted repos for pretty and consistent output
declare -a repos_sorted
if [ ${#repos_map[@]} -gt 0 ]; then
	while IFS= read -rd '' repo; do
		repos_sorted+=("${repo}")
	done < <(printf '%s\0' "${!repos_map[@]}" | sort -z)
fi

function should_use_colors() {
	if [[ ! -t 1 ]]; then
		return 1 # not a terminal, for example pager
	fi

	case "${TERM}" in
	xterm-color | *-256color) return 0 ;;
	esac

	if [ -x /usr/bin/tput ] && tput setaf 1 >&/dev/null; then
		return 0
	fi

	return 1
}

declare red=''
declare reset=''

if should_use_colors; then
	red='\e[0;31m'
	reset='\e[0m'
fi

for repo in "${repos_sorted[@]}"; do
	declare porcelain="${repos_map[${repo}]}"
	if [[ ! -z "${porcelain// /}" ]]; then
		echo -e "${red}${porcelain}${reset} ${repo}"
	fi
done
