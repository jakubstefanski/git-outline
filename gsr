#!/bin/bash

if ((${BASH_VERSION%%.*} < 4)); then
	echo "${0} requires Bash version 4 or later" >&2
	exit 1
fi

set -e

readonly SIGN_NONE=' '
readonly SIGN_LOOSE='L'
readonly SIGN_DIRTY='D'
readonly SIGN_REMOTE_UNAVAILABLE='R'
readonly PORCELAIN_STATUS_LENGTH=6

function check_status() {
	local repo="${1}"
	local status=()

	# Loose repositories
	[[ ! $(git remote 2>/dev/null) ]] && status+=("${SIGN_LOOSE}")

	# Dirty repositories
	[[ $(git status --porcelain) ]] && status+=("${SIGN_DIRTY}")

	# Remote unavailable
	! git fetch --quiet &>/dev/null && status+=("${SIGN_REMOTE_UNAVAILABLE}")

	# Padding and space for future extensions without breaking porcelain
	while [ "${#status[@]}" -lt "${PORCELAIN_STATUS_LENGTH}" ]; do
		status+=("${SIGN_NONE}")
	done

	printf '%s' "${status[@]}"
}

# Map (name => porcelain status)
declare -A repos_map
while IFS= read -rd '' gitconfig; do
	repo=$(dirname "$(dirname "${gitconfig}")")
	repos_map["${repo}"]="$(cd "${repo}" && check_status "${repo}")"
done < <(find . -type f -path '*/.git/config' -print0)

# Sorted repos for pretty and consistent output
repos_sorted=()
if [ ${#repos_map[@]} -gt 0 ]; then
	while IFS= read -rd '' repo; do
		repos_sorted+=("${repo}")
	done < <(printf '%s\0' "${!repos_map[@]}" | sort -z)
fi

function should_use_colors() {
	if [[ ! -t 1 ]]; then
		return 1 # not a terminal, for example pager
	fi

	case "${TERM}" in
	xterm-color | *-256color) return 0 ;;
	esac

	if [ -x /usr/bin/tput ] && tput setaf 1 >&/dev/null; then
		return 0
	fi

	return 1
}

red=''
reset=''

if should_use_colors; then
	red='\e[0;31m'
	reset='\e[0m'
fi

for repo in "${repos_sorted[@]}"; do
	echo -e "${red}${repos_map[${repo}]}${reset} ${repo}"
done
